<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>è¯­éŸ³é€šè¯æµ‹è¯•ï¼ˆæˆ¿é—´æ¨¡å¼ï¼‰</title>
    <style>
      body {
        font-family: sans-serif;
        padding: 20px;
      }
      #status {
        margin-top: 10px;
      }
      .log {
        color: #555;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <h1>ğŸ§ª WebSocket è¯­éŸ³æˆ¿é—´æµ‹è¯•</h1>
    <p>
      æˆ¿é—´å·ï¼ˆjoin_codeï¼‰ï¼š<input type="text" id="joinCode" value="IQJTM" />
      ä½ çš„IDï¼š<input type="text" id="userId" value="userA" />
    </p>
    <button id="start">ğŸ¤ å¼€å§‹è¯­éŸ³</button>
    <button id="stop">ğŸ›‘ åœæ­¢è¯­éŸ³</button>
    <button id="sendSine">ğŸ“¢ å‘é€æ­£å¼¦æ³¢éŸ³é¢‘</button>

    <div id="status">
      <p>çŠ¶æ€ï¼š<span id="wsStatus">æœªè¿æ¥</span></p>
      <p>å·²å‘é€éŸ³é¢‘å—æ•°ï¼š<span id="sentCount">0</span></p>
      <p>å·²æ¥æ”¶éŸ³é¢‘å—æ•°ï¼š<span id="recvCount">0</span></p>
    </div>

    <div class="log" id="log"></div>

    <script>
      let ws;
      let recorder;
      let sentCount = 0;
      let recvCount = 0;
      let heartbeatInterval;

      const log = (msg) => {
        const line = document.createElement("div");
        line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        document.getElementById("log").appendChild(line);
      };

      const updateStatus = () => {
        document.getElementById("wsStatus").textContent =
          ws?.readyState === WebSocket.OPEN ? "å·²è¿æ¥" : "æœªè¿æ¥";
        document.getElementById("sentCount").textContent = sentCount;
        document.getElementById("recvCount").textContent = recvCount;
      };

      document.getElementById("start").onclick = async () => {
        const joinCode = document.getElementById("joinCode").value.trim();
        const userId = document.getElementById("userId").value.trim();
        if (!joinCode || !userId) {
          alert("è¯·å¡«å†™æˆ¿é—´å·å’Œä½ çš„ID");
          return;
        }

        ws = new WebSocket(
          `ws://127.0.0.1:8080/api/v1/ws?join_code=${encodeURIComponent(
            joinCode
          )}&id=${encodeURIComponent(userId)}`
        );

        ws.onopen = async () => {
          log("WebSocket è¿æ¥å·²å»ºç«‹");
          updateStatus();
          // å¯åŠ¨å¿ƒè·³
          heartbeatInterval = setInterval(() => {
            if (ws.readyState === WebSocket.OPEN) ws.send("ping");
          }, 30000);

          // åªåœ¨è¿æ¥å»ºç«‹åå†æ‹¿æµã€å¯åŠ¨å½•éŸ³
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });
          recorder = new MediaRecorder(stream, { mimeType: "audio/webm" });
          recorder.ondataavailable = (e) => {
            if (ws.readyState === WebSocket.OPEN) {
              ws.send(e.data);
              sentCount++;
              updateStatus();
            }
          };
          recorder.start(200);
        };

        ws.onclose = (evt) => {
          log(`WebSocket å…³é—­ï¼Œcode=${evt.code}ï¼Œreason=${evt.reason}`);
          updateStatus();
          clearInterval(heartbeatInterval);
        };

        ws.onerror = (e) => {
          log("WebSocket é”™è¯¯ï¼š" + e);
          updateStatus();
        };

        ws.onmessage = async (event) => {
          log(
            "æ”¶åˆ°éŸ³é¢‘æ•°æ®ï¼Œç±»å‹ï¼š" +
              typeof event.data +
              " å¤§å°ï¼š" +
              (event.data.size || 0)
          );
          try {
            const blob = new Blob([event.data], { type: "audio/webm" });
            const url = URL.createObjectURL(blob);
            const audio = new Audio(url);
            audio.play();
            recvCount++;
            updateStatus();
          } catch (err) {
            log("æ¥æ”¶éŸ³é¢‘æ’­æ”¾å¤±è´¥ï¼š" + err);
          }
        };

        // è·å–éº¦å…‹é£éŸ³é¢‘
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: true,
        });
        recorder = new MediaRecorder(stream, { mimeType: "audio/webm" });

        recorder.ondataavailable = (e) => {
          log("å½•éŸ³æ•°æ®å¯ç”¨ï¼Œå¤§å°ï¼š" + e.data.size);
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(e.data);
            sentCount++;
            updateStatus();
          }
        };

        recorder.start(200); // æ¯200mså‘é€ä¸€æ¬¡æ•°æ®
      };

      document.getElementById("stop").onclick = () => {
        recorder?.stop();
        ws?.close();
        log("åœæ­¢é€šè¯");
      };

      document.getElementById("sendSine").onclick = async () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          log("WebSocket æœªè¿æ¥ï¼Œæ— æ³•å‘é€æµ‹è¯•éŸ³é¢‘");
          return;
        }
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const duration = 1; // ç§’
        const sampleRate = ctx.sampleRate;
        const frameCount = sampleRate * duration;
        const buffer = ctx.createBuffer(1, frameCount, sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < frameCount; i++) {
          data[i] = Math.sin((2 * Math.PI * 440 * i) / sampleRate) * 0.5;
        }
        const dest = ctx.createMediaStreamDestination();
        const source = ctx.createBufferSource();
        source.buffer = buffer;
        source.connect(dest);
        source.start();

        const recorder = new MediaRecorder(dest.stream, {
          mimeType: "audio/webm",
        });
        recorder.ondataavailable = (e) => {
          log("å‘é€æ­£å¼¦æ³¢éŸ³é¢‘ï¼Œå¤§å°ï¼š" + e.data.size);
          ws.send(e.data);
          sentCount++;
          updateStatus();
        };
        recorder.start();
        setTimeout(() => {
          recorder.stop();
          ctx.close();
        }, duration * 1000 + 100);
      };
    </script>
  </body>
</html>
